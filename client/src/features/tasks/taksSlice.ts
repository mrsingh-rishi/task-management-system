import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit"
import { RootState, AppThunk } from "../../app/store"
import { CreateTask, FetchAllTasks, UpdateTask } from "./taskAPI"
import { Task, Task2 } from "../../components/TaskItem"

export interface TaskState {
  tasks: Task[]
  status: "idle" | "loading" | "failed"
}

const initialState: TaskState = {
  tasks: [],
  status: "idle",
}

export const FetchAllTasksAsync = createAsyncThunk(
  "tasks/fetchAllTasks",
  async (token: string) => {
    const response = await FetchAllTasks(token)
    // The value we return becomes the `fulfilled` action payload
    return response.data
  },
)

export const CreateTaskAsync = createAsyncThunk(
  "tasks/createTask",
  async (Data: { taskData: Task2; token: string }) => {
    const response = await CreateTask(Data)
    return response.data
  },
)

export const UpdateTaskAsync = createAsyncThunk(
  "tasks/updateTask",
  async (Data: { taskData: Task; taskId: string; token: string }) => {
    const response = await UpdateTask(Data)
    return response.data
  },
)

export const tasksSlice = createSlice({
  name: "tasks",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(FetchAllTasksAsync.pending, (state) => {
        state.status = "loading"
      })
      .addCase(FetchAllTasksAsync.fulfilled, (state, action) => {
        state.status = "idle"
        state.tasks = action.payload.allTasks
      })
      .addCase(FetchAllTasksAsync.rejected, (state) => {
        state.status = "failed"
      })
      .addCase(CreateTaskAsync.pending, (state) => {
        state.status = "loading"
      })
      .addCase(CreateTaskAsync.fulfilled, (state, action) => {
        state.status = "idle"
        const task = action.payload
        state.tasks.push(task)
      })
      .addCase(CreateTaskAsync.rejected, (state) => {
        state.status = "failed"
      })
      .addCase(UpdateTaskAsync.pending, (state) => {
        state.status = "loading"
      })
      .addCase(UpdateTaskAsync.fulfilled, (state, action) => {
        state.status = "idle"
        const updatedTask = action.payload

        // Find the index of the task to be updated
        const index = state.tasks.findIndex((t) => t._id === updatedTask._id)

        // If the task is found, create a new array with the updated task
        if (index !== -1) {
          state.tasks = [
            ...state.tasks.slice(0, index),
            updatedTask,
            ...state.tasks.slice(index + 1),
          ]
        }
      })

      .addCase(UpdateTaskAsync.rejected, (state) => {
        state.status = "failed"
      })
  },
})

export const selectTasks = (state: RootState) => state.tasks.tasks

export default tasksSlice.reducer
